#
p
ggsave(file="figures/stacked_pie_gene_category_summary.pdf", plot=p,width=8, height=8)
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 2)+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1)+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-1, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
p
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1)+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1)+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-1, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
p
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1)+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1)+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-0.5, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
p
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1)+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1)+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-0.25, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
p
ggsave(file="figures/stacked_pie_gene_category_summary.pdf", plot=p,width=8, height=8)
library(ggplot2)
library(RColorBrewer)
library(data.table)
df = read.csv('input/WPS/gene_category_summary.csv',row.names = 1)
df$undetermined = df$total - df$responsive - df$nonresponsive
# the first layer
data2 = data.frame(category = rownames(df), value = df$total)
data2 = data2[data2$category %in% c('zero','low','dynamic','high'),]
data2$layer=1
data2$value1=data2$value/sum(data2$value) # the position in the circle
# align the order of the table
data2 = rbind(data2[data2$category == 'high',],
data2[data2$category == 'dynamic',],
data2[data2$category == 'low',],
data2[data2$category == 'zero',])
# the second layer
tmp = as.data.table(df[,2:4])
tmp$category = rownames(df)
data1= as.data.frame(melt(tmp,id.vars = 'category'))
colnames(data1) = c('category','responsiveness','value')
data1$layer=2
data1 = rbind(data1[data1$category == 'high',],
data1[data1$category == 'dynamic',],
data1[data1$category == 'low',],
data1[data1$category == 'zero',])
data1$value1=data1$value/sum(data1$value)
# make sure the row orders of data1 and data2 are aligned and layed out in the order of display
colors = c( 'undetermined' = 'white',
'responsive' = '#D95319',
'nonresponsive' = 'grey',
'high' = '#77AC30',
'dynamic' = '#EDB120',
'low' = '#7E2F8E',
'zero' = '#A2142F')
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1)+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1)+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-0.25, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
#
p
ggsave(file="figures/stacked_pie_gene_category_summary.pdf", plot=p,width=8, height=8)
library(ggplot2)
library(RColorBrewer)
library(data.table)
df = read.csv('input/WPS/gene_category_summary.csv',row.names = 1)
df$undetermined = df$total - df$responsive - df$nonresponsive
# the first layer
data2 = data.frame(category = rownames(df), value = df$total)
data2 = data2[data2$category %in% c('zero','low','dynamic','high'),]
data2$layer=1
data2$value1=data2$value/sum(data2$value) # the position in the circle
# align the order of the table
data2 = rbind(data2[data2$category == 'high',],
data2[data2$category == 'dynamic',],
data2[data2$category == 'low',],
data2[data2$category == 'zero',])
# the second layer
tmp = as.data.table(df[,2:4])
tmp$category = rownames(df)
data1= as.data.frame(melt(tmp,id.vars = 'category'))
colnames(data1) = c('category','responsiveness','value')
data1$layer=2
data1 = rbind(data1[data1$category == 'high',],
data1[data1$category == 'dynamic',],
data1[data1$category == 'low',],
data1[data1$category == 'zero',])
data1$value1=data1$value/sum(data1$value)
# make sure the row orders of data1 and data2 are aligned and layed out in the order of display
colors = c( 'undetermined' = 'white',
'responsive' = '#D95319',
'nonresponsive' = 'grey',
'high' = '#77AC30',
'dynamic' = '#EDB120',
'low' = '#7E2F8E',
'zero' = '#A2142F')
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1, color = 'black')+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1, color = 'black')+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-0.25, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
#
p
ggsave(file="figures/stacked_pie_gene_category_summary.pdf", plot=p,width=8, height=8)
df
colSums(df)
colSums(df[1:4,])
888/1318
888/1314
906/1308
install.packages("pheatmap")
install.packages("eulerr")
library(eulerr)
library(matrixStats)
install.packages("matrixStats")
myTbl = read.csv('output/fluxTable.csv')
myTbl = read.csv('output/fluxTable.csv')
library(eulerr)
library(matrixStats)
library(stringr)
myTbl = read.csv('output/fluxTable.csv')
tbl = myTbl[,c("OFD_bounded_exp_resp_simi",
"OFD_bounded_exp_resp",
"OFD_bounded_exp_simi",
"OFD_bounded_exp_only",
"OFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'OFD_bounded_')
fit1 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
# double check if the fit of euler plot area is good
fit1
totalN = sum(rowAnys(as.matrix(myTbl[,c("OFD_bounded_exp_resp_simi","OFD_bounded_exp_resp","OFD_bounded_exp_simi","OFD_bounded_exp_only","OFD_bounded_no_data")])))
sum(fit1$original.values)
# total count should equal
totalN == sum(fit1$original.values)
pdf(paste('figures/euler_plot_bounded_OFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit1, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
tbl = myTbl[,c("PFD_bounded_exp_resp_simi",
"PFD_bounded_exp_resp",
"PFD_bounded_exp_simi",
"PFD_bounded_exp_only",
"PFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'PFD_bounded_')
fit2 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
fit2
totalN = sum(rowAnys(as.matrix(myTbl[,c("PFD_bounded_exp_resp_simi","PFD_bounded_exp_resp","PFD_bounded_exp_simi","PFD_bounded_exp_only","PFD_bounded_no_data")])))
# total count should equal
totalN == sum(fit2$original.values)
pdf(paste('figures/euler_plot_bounded_PFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit2, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
library(eulerr)
library(matrixStats)
library(stringr)
# load flux table
myTbl = read.csv('output/fluxTable.csv')
# some supplementary figures
tbl = myTbl[,c("OFD_bounded_exp_resp_simi",
"OFD_bounded_exp_resp",
"OFD_bounded_exp_simi",
"OFD_bounded_exp_only",
"OFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'OFD_bounded_')
fit1 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
# double check if the fit of euler plot area is good
fit1
totalN = sum(rowAnys(as.matrix(myTbl[,c("OFD_bounded_exp_resp_simi","OFD_bounded_exp_resp","OFD_bounded_exp_simi","OFD_bounded_exp_only","OFD_bounded_no_data")])))
# total count should equal
totalN == sum(fit1$original.values)
pdf(paste('figures/euler_plot_bounded_OFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit1, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
tbl = myTbl[,c("PFD_bounded_exp_resp_simi",
"PFD_bounded_exp_resp",
"PFD_bounded_exp_simi",
"PFD_bounded_exp_only",
"PFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'PFD_bounded_')
fit2 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
fit2
totalN = sum(rowAnys(as.matrix(myTbl[,c("PFD_bounded_exp_resp_simi","PFD_bounded_exp_resp","PFD_bounded_exp_simi","PFD_bounded_exp_only","PFD_bounded_no_data")])))
# total count should equal
totalN == sum(fit2$original.values)
pdf(paste('figures/euler_plot_bounded_PFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit2, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
library(ggplot2)
library(RColorBrewer)
library(data.table)
df = read.csv('input/WPS/gene_category_summary.csv',row.names = 1)
df$undetermined = df$total - df$responsive - df$nonresponsive
# the first layer
data2 = data.frame(category = rownames(df), value = df$total)
data2 = data2[data2$category %in% c('zero','low','dynamic','high'),]
data2$layer=1
data2$value1=data2$value/sum(data2$value) # the position in the circle
# align the order of the table
data2 = rbind(data2[data2$category == 'high',],
data2[data2$category == 'dynamic',],
data2[data2$category == 'low',],
data2[data2$category == 'zero',])
# the second layer
tmp = as.data.table(df[,2:4])
tmp$category = rownames(df)
data1= as.data.frame(melt(tmp,id.vars = 'category'))
colnames(data1) = c('category','responsiveness','value')
data1$layer=2
data1 = rbind(data1[data1$category == 'high',],
data1[data1$category == 'dynamic',],
data1[data1$category == 'low',],
data1[data1$category == 'zero',])
data1$value1=data1$value/sum(data1$value)
colors = c( 'undetermined' = 'white',
'responsive' = '#D95319',
'nonresponsive' = 'grey',
'high' = '#77AC30',
'dynamic' = '#EDB120',
'low' = '#7E2F8E',
'zero' = '#A2142F')
p=ggplot() +
geom_col(aes(x = layer, y = value1, fill = category,group=layer),
data =data2,width = 1, color = 'black')+
geom_text(aes(label = category, x= layer, y = value1),
data = data2,position=position_fill(vjust=0.5))+
geom_col(aes(x = layer, y = value1, fill = responsiveness,group=layer),
data = data1,width = 1, color = 'black')+
geom_text(aes(label = value, x= layer, y = value1),
data = data1,position=position_fill(vjust=0.5))+
scale_fill_manual(values = colors)+
xlim(c(-0.25, 3))+
coord_polar(theta = "y") +
coord_polar(theta = "y") + theme_classic()
p
ggsave(file="figures/stacked_pie_gene_category_summary.pdf", plot=p,width=8, height=8)
library(pheatmap)
library(stringr)
# reproduce the heatmap
input = read.csv('./../../MetabolicLibrary/2_DE/output/cosineSimilarity_FC_denoised_stationery_metabolic.csv',row.names = 1)
N_DETbl = read.csv('./../../MetabolicLibrary/2_DE/output/RNAi_condition_metaInfo.csv',row.names = 1)
WBID = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WBIDtbl.txt',sep = '\t')
ann2 = data.frame(conID = colnames(input))
ann2$log2NDE = log2(N_DETbl$N_DE_targetExcluded[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))])
rownames(ann2) = ann2$conID
wormPath = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WormPaths_Tables/wormPathTable.csv')
wormpathLevels = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WormPaths_Tables/LEVEL1_GENES.csv',header = F)
ann2$RNAiName = N_DETbl$RNAi_geneName[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))]
ann2$WBID = N_DETbl$RNAi_WBID[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))]
ann2$wormPath = wormPath$LEVEL.1[match(ann2$WBID, wormPath$WormBase.ID)]
mylevels = wormpathLevels$V1
ann_col = list()
for (i in 1:length(mylevels)){
if (any(str_detect(ann2$wormPath, paste(mylevels[i],';',sep = '')),na.rm = T) |
any(str_detect(ann2$wormPath, paste(mylevels[i],'$',sep = '')),na.rm = T)){
ann2[,mylevels[i]] = 'No'
ann2[which(str_detect(ann2$wormPath, paste(mylevels[i],';',sep = ''))),mylevels[i]] = 'Yes'
ann2[which(str_detect(ann2$wormPath, paste(mylevels[i],'$',sep = ''))),mylevels[i]] = 'Yes'
cols = c('red','white')
names(cols) = c('Yes','No')
ann_col[[mylevels[i]]] = cols
}
}
# we directly use the cosine distance (1-cosine similarity) to cluster
pdf('figures/DE_similarity_used_pair_heatmap.pdf',width = 10,height = 12)
upperl = 0.5
seq1 = seq(-upperl,upperl,length.out = 100)
cl_cosine = fastcluster::hclust(as.dist(1-as.matrix(input)), method = 'complete') # for reproducibility; the original hclust can produce the same tree but with same-height branches reordered!
color_palette <- rev(colorRampPalette(c("red", "grey100", "blue"))(100))
pheatmap(input, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,annotation_col = ann2[,-which(colnames(ann2) %in% c('conID','WBID','RNAiName','wormPath')),drop = F]
,annotation_colors = ann_col
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
# produce the labeling heatmap
df = read.csv('input/WPS/DEsim_table_integration_summary.csv')
df$pair_gene1 = str_replace_all(df$pair_gene1,'\\.','_')
df$pair_gene2 = str_replace_all(df$pair_gene2,'\\.','_')
mat = matrix(data = 0, nrow = nrow(input), ncol = ncol(input))
mat = as.data.frame(mat)
colnames(mat) = str_replace_all(colnames(input),'\\.','_')
rownames(mat) = str_replace_all(rownames(input),'\\.','_')
for (i in 1:nrow(df)){
mat[df$pair_gene1[i], df$pair_gene2[i]] = 1
}
pheatmap(mat, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
dev.off()
dev.off()
# we directly use the cosine distance (1-cosine similarity) to cluster
pdf('figures/DE_similarity_used_pair_heatmap.pdf',width = 10,height = 12)
upperl = 0.5
seq1 = seq(-upperl,upperl,length.out = 100)
cl_cosine = fastcluster::hclust(as.dist(1-as.matrix(input)), method = 'complete') # for reproducibility; the original hclust can produce the same tree but with same-height branches reordered!
color_palette <- rev(colorRampPalette(c("red", "grey100", "blue"))(100))
pheatmap(input, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,annotation_col = ann2[,-which(colnames(ann2) %in% c('conID','WBID','RNAiName','wormPath')),drop = F]
,annotation_colors = ann_col
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
# produce the labeling heatmap
df = read.csv('input/WPS/DEsim_table_integration_summary.csv')
df$pair_gene1 = str_replace_all(df$pair_gene1,'\\.','_')
df$pair_gene2 = str_replace_all(df$pair_gene2,'\\.','_')
mat = matrix(data = 0, nrow = nrow(input), ncol = ncol(input))
mat = as.data.frame(mat)
colnames(mat) = str_replace_all(colnames(input),'\\.','_')
rownames(mat) = str_replace_all(rownames(input),'\\.','_')
for (i in 1:nrow(df)){
mat[df$pair_gene1[i], df$pair_gene2[i]] = 1
}
pheatmap(mat, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
dev.off()
library(pheatmap)
library(stringr)
# reproduce the heatmap
input = read.csv('./../../MetabolicLibrary/2_DE/output/cosineSimilarity_FC_denoised_stationery_metabolic.csv',row.names = 1)
N_DETbl = read.csv('./../../MetabolicLibrary/2_DE/output/RNAi_condition_metaInfo.csv',row.names = 1)
WBID = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WBIDtbl.txt',sep = '\t')
ann2 = data.frame(conID = colnames(input))
ann2$log2NDE = log2(N_DETbl$N_DE_targetExcluded[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))])
rownames(ann2) = ann2$conID
wormPath = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WormPaths_Tables/wormPathTable.csv')
wormpathLevels = read.csv('./../../MetabolicLibrary/input_data/otherTbls/WormPaths_Tables/LEVEL1_GENES.csv',header = F)
ann2$RNAiName = N_DETbl$RNAi_geneName[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))]
ann2$WBID = N_DETbl$RNAi_WBID[match(ann2$conID, str_replace(N_DETbl$RNAiID,' ','_'))]
ann2$wormPath = wormPath$LEVEL.1[match(ann2$WBID, wormPath$WormBase.ID)]
mylevels = wormpathLevels$V1
ann_col = list()
for (i in 1:length(mylevels)){
if (any(str_detect(ann2$wormPath, paste(mylevels[i],';',sep = '')),na.rm = T) |
any(str_detect(ann2$wormPath, paste(mylevels[i],'$',sep = '')),na.rm = T)){
ann2[,mylevels[i]] = 'No'
ann2[which(str_detect(ann2$wormPath, paste(mylevels[i],';',sep = ''))),mylevels[i]] = 'Yes'
ann2[which(str_detect(ann2$wormPath, paste(mylevels[i],'$',sep = ''))),mylevels[i]] = 'Yes'
cols = c('red','white')
names(cols) = c('Yes','No')
ann_col[[mylevels[i]]] = cols
}
}
# we directly use the cosine distance (1-cosine similarity) to cluster
pdf('figures/DE_similarity_used_pair_heatmap.pdf',width = 10,height = 12)
upperl = 0.5
seq1 = seq(-upperl,upperl,length.out = 100)
cl_cosine = fastcluster::hclust(as.dist(1-as.matrix(input)), method = 'complete') # for reproducibility; the original hclust can produce the same tree but with same-height branches reordered!
color_palette <- rev(colorRampPalette(c("red", "grey100", "blue"))(100))
pheatmap(input, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,annotation_col = ann2[,-which(colnames(ann2) %in% c('conID','WBID','RNAiName','wormPath')),drop = F]
,annotation_colors = ann_col
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
# produce the labeling heatmap
df = read.csv('input/WPS/DEsim_table_integration_summary.csv')
df$pair_gene1 = str_replace_all(df$pair_gene1,'\\.','_')
df$pair_gene2 = str_replace_all(df$pair_gene2,'\\.','_')
mat = matrix(data = 0, nrow = nrow(input), ncol = ncol(input))
mat = as.data.frame(mat)
colnames(mat) = str_replace_all(colnames(input),'\\.','_')
rownames(mat) = str_replace_all(rownames(input),'\\.','_')
for (i in 1:nrow(df)){
mat[df$pair_gene1[i], df$pair_gene2[i]] = 1
}
pheatmap(mat, color = color_palette,breaks = seq1
,show_rownames = F,show_colnames = F
,fontsize = 7,annotation_legend = F
,cellheight = 1,cellwidth = 1
,cluster_rows = cl_cosine,cluster_cols = cl_cosine
)
dev.off()
library(eulerr)
library(matrixStats)
library(stringr)
# load flux table
myTbl = read.csv('output/fluxTable.csv')
# some supplementary figures
tbl = myTbl[,c("OFD_bounded_exp_resp_simi",
"OFD_bounded_exp_resp",
"OFD_bounded_exp_simi",
"OFD_bounded_exp_only",
"OFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'OFD_bounded_')
fit1 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
# double check if the fit of euler plot area is good
fit1
totalN = sum(rowAnys(as.matrix(myTbl[,c("OFD_bounded_exp_resp_simi","OFD_bounded_exp_resp","OFD_bounded_exp_simi","OFD_bounded_exp_only","OFD_bounded_no_data")])))
# total count should equal
totalN == sum(fit1$original.values)
pdf(paste('figures/euler_plot_bounded_OFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit1, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
tbl = myTbl[,c("PFD_bounded_exp_resp_simi",
"PFD_bounded_exp_resp",
"PFD_bounded_exp_simi",
"PFD_bounded_exp_only",
"PFD_bounded_no_data")]
colnames(tbl) = str_remove(colnames(tbl),'PFD_bounded_')
fit2 <- euler(tbl,
shape = "circle",
#loss = 'region',
#loss_aggregator = 'max',
control = list(extraopt = TRUE, extraopt_threshold = 0)
)
fit2
totalN = sum(rowAnys(as.matrix(myTbl[,c("PFD_bounded_exp_resp_simi","PFD_bounded_exp_resp","PFD_bounded_exp_simi","PFD_bounded_exp_only","PFD_bounded_no_data")])))
# total count should equal
totalN == sum(fit2$original.values)
pdf(paste('figures/euler_plot_bounded_PFD_rxns.pdf',sep = ''),width = 7,height = 7)
plot(fit2, quantities = TRUE, fill = c('#FFA07A','#D8BFD8','#F0E68C','#E0FFFF','#87CEEB'),
main = paste('make sure total is ',totalN))
dev.off()
